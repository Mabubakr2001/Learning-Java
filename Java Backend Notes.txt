1- Maven is a Java build tool used to compile, test, and package the code. It also manages dependencies and automatically downloads all necessary libraries from a central repository (equivalent to the npm package manager in Frontend).

2- Maven is like Vite in the frontend world. When choosing Maven with Spring Initializer (similar to npm create vite@latest), the Initializer uses Spring Boot to quickly scaffold the project structure, allowing developers to focus on writing business logic rather than setup.

3- Without Spring Initializer, we would need to configure Spring manually — setting up XML config files, specifying dependencies ourselves, and handling server setup — much like using plain JavaScript and manually configuring Webpack or Babel.

4- After using Spring Initializer, one of the files generated is pom.xml (POM = Project Object Model). This file is the equivalent of package.json in frontend projects. It defines the project structure, manages dependencies, includes metadata, and lists plugins used by Maven.

5- Just like we can configure the name of the production folder in frontend projects (e.g., dist/ or build/) to hold all bundled and optimized code, in Java backend development we can choose between generating a .jar (Java ARchive) or a .war (Web Application ARchive) file when initializing our project with Spring Initializr. After compiling the .java source files into .class files, the build tool (like Maven or Gradle) packages these compiled classes — along with resources and dependencies — into a .jar or .war file. These files are placed inside the target/ directory by default (for Maven), and this happens during the build phase, not during initialization.
The choice between .jar and .war is defined in the pom.xml via the <packaging> tag and determines how the application will be deployed.

6- after setting up the Java project via the Spring Initializer, if we chose the .jar packaging, so Spring Boot auto-configures Tomcat and runs it as part of our application (via spring-boot-starter-web). But if we chose to use .war packaging, then we need to deploy our packaged app to a standalone Tomcat server (like copying the .war file to the webapps/ folder of a Tomcat installation).


7- Tomcat is a lightweight java web server (specifically a Servlet container), it handles HTTP requests and responses and runs our backend java code, It's actually a real server for APIs and it can be used for production unlike the dev server in the Frontend world that is not for production. Unlike the dev server that shows the UI, Tomcat serves APIs and handles logic. It's like Express.js in Node or the Vite dev server for frontend.

8- We need Tomcat because when we write a backend with Java (e.g., a REST API), that code needs to be hosted on a web server so it can listen for HTTP requests (like GET /users), process those requests (e.g., talk to the database), and return a response (e.g., a list of users in JSON). So Tomcat acts as that server. It receives requests and passes them to your Java code.

9- Spring Boot is a frameword built on top of Traditional Spring and makes backend development faster and simpler. It uses auto-configuration, convention over configuration, and starter dependencies to eliminate boilerplate. It packages the app into a .jar that includes an embedded Tomcat server, so you can just run your app directly without needing to install Tomcat manually.

10- Before Spring Boot, Java developers used Traditional Spring, which required a lot of manual configuration. You had to write long XML files to wire components, define beans, manage dependencies manually, and deploy apps by copying .war files into a standalone Tomcat server. It gave fine-grained control but slowed development down with boilerplate setup.

11- A Servlet is a Java class that handles HTTP requests and generates responses — usually HTML, JSON, or other web data. It runs inside a Servlet container (like Tomcat). Think of a Servlet as a Java version of what you'd write in Express.js like:

	app.get("/hello", (req, res) => {
   	    res.send("Hello World");
	});

12- A normal Java class is just a regular class we write for logic, utilities, data models, etc. It doesn’t depend on any web framework or server. A Servlet class on the other hand, is a special type of Java class used in web development to handle HTTP requests (like GET and POST). It extends HttpServlet, and it runs inside a web server like Tomcat.

13- A controller is a Java class that handles incoming HTTP requests from the client and sends back responses. It acts as the bridge between the client and your backend logic or database. We define a controller by typing the controller annotation like the @RestController.

14- We have mapping annotations in Spring Boot also, like @GetMapping, @PostMapping, @PutMapping, and @DeleteMapping. Each of these annotations maps an HTTP request (GET, POST, PUT, DELETE) to the Java method defined below it. This allows the method to handle that type of HTTP request and return a response — typically as JSON in a REST API.

Spring MVC:-

15- Spring MVC, is a framework for building web apps. It gives us all the tools we need to handle HTTP requests, generate web pages, and return data to clients. It's part of the larget Spring ecosystem and Spring Boot makes it easy to use.

16- MVC stands for Model View Controller, which is a popular design pattern for organizing code.

17- In Spring MVC (MVC = Model View Controller), we have three main components. Model, View, and Controller.
   
	- Model handles the data and business logic.
	- View is what the user sees.
	- Controller is the middleman. It takes a request, processes it, and decides what response to send back.

18- When the user enters the URL "example.com/hello" in the browser, the browser sends an HTTP request to the /hello endpoint (path), then Spring Boot (through Spring MVC) receives the request and passes it to a controller which listening for requests to the /hello endpoint, so this method gets called by its controller, and that might talk to a database and fetch some data, then it returns a response, and boom, the JSON object or an HTML page is retrieved by the client.

19- JDBC (Java Database Connectivity) is a low-level Java API that allows Java applications to connect to relational databases (like MySQL, PostgreSQL, Oracle). It sends SQL queries to the database, retrieves results from the database, and manages connections, statements, and result sets. It gives us full control over SQL, and it's lightweight and simple for small projects.

20- JPA (Java Persistence API) is a Java specification (not a tool or framework) that defines how to map Java objects (entities) to database tables. It abstracts away SQL and replaces it with object-based operations. It’s used in enterprise-grade Java apps.
Think of JPA as the interface.

21- Hibernate (JPA Implementation) is the most popular implementation of JPA. It’s a library that uses JPA under the hood and provides powerful ORM (Object-Relational Mapping) features. it maps Java classes to database tables, lets you query with Java (using JPQL/HQL or method-based queries), manages the database connection and transactions, and handles complex relationships (like OneToMany, ManyToMany). It gives us much cleaner and maintainable code, no manual SQL for most operations, and it also supports automatic schema generation, lazy loading, caching.

Abstract Notes and Concepts:

1- REST is an architectural style for designing networked applications. It defines a set of rules and conventions for building and interacting with web services over HTTP. In REST, everything is a resource (like /users or /products), and each resource is accessed by the URL that locates this resource from the server, that's why it's called Uniform Resource Locater.

2- REST stands for (Representational State Transfer). When a client (like a browser or frontend app) interacts with a resource (like a user or a product), it doesn’t get the actual resource from the server — it gets a representation of it. That representation is usually JSON, XML, or HTML, and it describes the current state of the resource. So the client transfers the "representation" of a resource's current "state" over HTTP.

3- A REST API is a practical implementation of a web service that follows REST principles. It provides endpoints (URLs) that clients (like frontend apps or mobile apps) can interact with using HTTP methods (GET, POST, PUT, DELETE) to perform actions on resources.

4- An endpoint is a URL path that the backend exposes so that clients (like frontend apps or mobile apps) can send HTTP requests to this endpoint and receive responses. It gives us access to that resource, using HTTP methods (GET, POST, etc.). In Spring Boot, endpoints are defined using annotations like @GetMapping, @PostMapping, etc., inside controller classes. When the app runs on Tomcat (default at localhost:8080), these endpoints become accessible via browser or HTTP clients (e.g., GET http://localhost:8080/hello). Endpoints must be explicitly mapped in a controller using annotations like @GetMapping("/") to avoid that error.

5- We can call "http://localhost:8080/products" an endpoint, because it points to a resour ce (the products collection).
"http://localhost:8080" is also technically an endpoint (it's the root endpoint), but unless the backend defines a controller for /, it won’t return a resource — and we'll get the default Whitelabel Error Page from Spring Boot.

6- The most popular logging frameworks for debugging and monitoring my Java backend projects are SLF4J, Log4j, and Logback. We need these logging frameworks to track behavior, catch errors, and maintain visibility into our application — especially in production where println() just doesn’t cut it. Because in production, we don’t care about debug prints — but we need errors, and println() can't filter "debug" vs "critical error" logs. Also println() is synchronous which might blocks our app, while logging frameworks on the other hand use async logging (non-blocking).

7- Postman is a powerful tool used in backend development to test, debug, and document REST APIs. It allows developers to send HTTP requests (GET, POST, PUT, DELETE, etc.) to backend endpoints and view responses directly, without needing a frontend client. Postman simplifies verifying API functionality, troubleshooting issues, automating tests, and sharing API collections with the team, making backend development and collaboration faster and more efficient.

9- With Spring Boot apps, drivers are needed only when our application needs to interact with something external, like a database.
For example, if we choose to use an external database like MySQL, and during the initialization of our Spring Boot app (via Spring Initializr) we don’t include the MySQL driver dependency, the app will throw errors at runtime and won’t function properly.
That’s because without MySQL’s driver, the JVM can’t "see" or communicate with the database — it doesn't know how to speak the database’s language. It’s just like plugging in a keyboard but not installing its driver: the operating system won’t recognize the keyboard, and we won’t be able to type.

10- A driver is a piece of software (a library) that acts as a bridge between two systems that don't speak the same language.
In the case of a Spring Boot application, a driver allows the app to communicate with an external system like a database (e.g., MySQL, PostgreSQL). Similarly, in an operating system, a keyboard driver enables the OS to understand and respond to signals from the physical keyboard.

11- We don't need the driver for things that are already part of the Java standard library, fully handled within the JVM itself, or are just part of your own internal code.

12- Without an API, we can't interact properly with the server or database. For example, if we don’t define any endpoints in our Spring Boot application, the server won’t know how to handle incoming requests. So, when we try to access a URL in the browser or make a request, the server responds with the Whitelabel Error Page, because there’s no matching route or logic to handle that request.
That’s why we need to create an API with clearly defined endpoints, so the server knows how to respond to different types of requests (GET, POST, etc.).

13- SSR (Server-Side Rendering) is when the HTML is generated on the server and sent to the client already rendered. The server does all the rendering work, and the browser just displays the final result. Example: Your Spring Boot backend returns a fully built HTML page (like from a Thymeleaf or JSP template), so the user sees content immediately.

14- CSR (Client-Side Rendering) is when the backend sends raw data (usually JSON), and the frontend app (like React or Angular) builds the UI in the user's browser. Example: Your Spring Boot backend returns a JSON object like { name: "John", age: 30 }, and your frontend (React, etc.) uses that to build and render the UI.